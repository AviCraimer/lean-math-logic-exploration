import Mathlib.Tactic
import Mathlib.Data.Vector
set_option pp.coercions false


-- Definition 2.6 p. 14
-- I don't actually use this. Too complicated. I just use the built in String type to name atomic formulas and connectives.
structure StringAlg.{u} (α : Type u) where
  Sym : Type u := α
  Str : Type u -> Type u
  StrSet := Str Sym
  symAsString : Sym → StrSet
  symAsString_injective : Function.Injective symAsString
  concat (s1 s2: StrSet ) : StrSet
  concat_assoc: concat (concat a b) c = concat a (concat b c)
  -- Symbol strings are atomic, that is no two strings concatenate to make them. Note this also implies we don't have an empty string.
  atomic (a: Sym): ¬ ∃ (b c: StrSet), (concat b c) = symAsString a
  -- All strings are finitely generated by symbols.
  finGen (s:StrSet ): (∃ (x:Sym), symAsString x = s) ∨ ∃ (x y: Sym) (rest: List Sym),
    let list : List Sym := (y::rest)
    let symStrings := list.map symAsString
    let targetString := symStrings.foldl concat (symAsString x)
    s = targetString
  decomposition {a x x' y y': StrSet} : a = concat x x' ∧ a = concat y y' → x = y ∧ x' = y'




-- Definition 2.7 Connectives

inductive Connective (n: Nat)
| connect (arity: ℕ) (name: String) : Connective n
deriving DecidableEq

open Connective
-- Technically this should be well-ordered type not just String

def Connective.arity (_: Connective n) := n

inductive AtomicFormula
| atom (name: String)
deriving DecidableEq

open AtomicFormula

mutual
  inductive Formula
  | atomic (a: AtomicFormula)
  | composite (c: Connective n) (args: Args n)
  deriving DecidableEq

  inductive Args : Nat → Type
  | nil : Args 0
  | cons : Formula → Args n → Args (n+1)
  deriving DecidableEq
end
open Formula


def Args.arity (_:Args n) := n


mutual
def Formula.subformulas (f: Formula):Finset Formula :=
match f with
| atomic _ => {f}
| composite _ args =>  {f} ∪ args.getArgsFormulas args.arity

def Args.getArgsFormulas (n: ℕ) (args: Args n) :=
  match n with
  | (m+1) =>
    match args with
    | Args.cons P (args': Args m) => (P.subformulas) ∪ (Args.getArgsFormulas m args')
  | _ => ∅
end


def Args.every (f: Formula -> Prop)(args: Args n) :=
match args with
| cons P args' => f P ∧ (every f args')
| nil => True

-- A finite set of n-ary connective for each arity.
def FiniteConnectives :=  (n:ℕ) -> ↑(Finset (Connective n))


mutual
  def isInLanguage (fc: FiniteConnectives)(f: Formula): Prop :=
    match f with
    | atomic _ => True
    | composite c args => (c ∈ fc c.arity) ∧ isInLanguageArgs fc args

  def isInLanguageArgs (fc: FiniteConnectives) : ∀ {n : ℕ}, Args n → Prop
  | _, (Args.cons P args') => isInLanguage fc P ∧ isInLanguageArgs fc args'
  | _, _ => True
end


structure Language where
  connectives : FiniteConnectives
  Formulas := {f: Formula | isInLanguage connectives f  }
  Atoms := {f: Formula | ∃(A:AtomicFormula), f = (atomic A)  }
  Composites := {f: Formula | isInLanguage connectives f ∧ ¬∃(A:AtomicFormula), f = (atomic A) }




























-- Lemma 2.9 p. 16
-- theorem decomposition (L: Language)(C1 C2: L.Composites) : C1 = C2 →
--   match C1.val, C2.val with
--    | (composite (connect n nm) args), (composite (connect n' nm') args') => n = n' ∧ nm = nm' ∧ args = args'  := sorry
